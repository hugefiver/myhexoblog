---
title: 【编程作业】泛型编程-基于模板的迭代器
date: 2018-04-16 12:25:28
categories: 
	- 日常
	- 课程
tags:
	- 课程作业
	- C/C++
toc: false
---
最近C++课有个作业让我设计一个适用于基于模板的队列和栈的迭代器<!--more-->，可是因为课上稍微的恍惚了一下，导致课后完全不知道怎么写QAQ。然后到网上查了下，更加懵逼了，竟然每个人设计的都完全不一样。本着优先完成作业的原则，随便copy了一段代码交上去。后来感觉迭代器这玩意还是很有趣的，刚好最近有点时间，随便设计了一个写了出来（继承真的是令人崩溃）。

{% raw %}
<link rel="stylesheet" href="https://resource.rurilove.moe/statics/aplayer/APlayer.min.css">
<script src="https://resource.rurilove.moe/statics/aplayer/APlayer.min.js"></script>
<div id="player" class="aplyer" style="width: 100%;margin: auto "></div>
<script type="text/javascript">
	var ap = new APlayer({ 
	    element: document.getElementById('player'), 
	    narrow: false, 
	    autoplay: true, 
	    showlrc: false, 
	    music: { 
	        title: 'SHINY DAYS (off vocal)', 
	        author: '亜咲花 ', 
	        url: 'https://resource.rurilove.moe/musics/03.mp3', 
	        pic: 'https://resource.rurilove.moe/images/mufront/03.jpg' 
	    } 
	}); 
	ap.init(); 
</script>
{% endraw %}

**Warming：** *本文中出现的代码均未进行严谨的验证，可能会有一定的错误和不合理性，仅供学习和探讨之用。如有错误或可改善之处，欢迎指出。*

完整的代码在这里：[Github Gist](https://git.io/vpJXa) 
使用模板时写进多个文件总会有奇怪的报错，干脆直接写在main文件算了。

代码以下：
```cpp
//储存数据的节点结构体
template <typename T>
struct tNode{
    T data;
    tNode* next;
};

//迭代器基类，由Queue类继承，使用基类指针进行操作，提供迭代器相关功能
template <typename S>
class IteratorBase{
protected:
    S *headNode;
    S *totalNode;
public:
    IteratorBase(S* headNode){
        this->headNode = headNode;
        totalNode = headNode;
    }
    void setHead(S* node){
        totalNode = headNode = node;
    }
    void setToHead(){
        totalNode = headNode;
    }
    virtual void first(){
        totalNode = headNode;
    }
    virtual void next(){
        totalNode = totalNode->next;
    }
    virtual S& total(){
        return *totalNode;
    }
    virtual bool isEnd()=0;
};

//给迭代器套壳，避免直接使用指针进行操作，给予用户面向对象的原生体验
template <typename T>
class Iterator{
private:
    IteratorBase<tNode<T>> *Itera;
public:
    Iterator(IteratorBase<tNode<T>> *ptr){
        Itera=ptr;
    }
    void first(){
        Itera->first();
    }
    void next(){
        Itera->next();
    }
    T current(){
        return Itera->total().data;
    }
    bool isDone(){
        return Itera->isEnd();
    }
};

//Queue类，继承迭代器基类
template <typename T>
class Queue: private IteratorBase<tNode<T>>{
private:
    tNode<T> *head,*tail;
    int len;
    void iteraUpdate();

public:
    Queue():IteratorBase<tNode<T>>(0){
        head=tail=0;
        len = 0;
    }
    ~Queue();
    void append(T data);
    bool del();
    T get();
    bool isEmpty();

    bool isEnd(){
        return !(IteratorBase<tNode<T>>::totalNode);
    }
};

template<typename T>
void Queue<T>::iteraUpdate() {
    IteratorBase<tNode<T>>::setHead(head);
}

template<typename T>
Queue<T>::~Queue() {
    tNode<T> *p = head,*temp;
    while(p){
        temp = p->next;
        delete p;
        p = temp;
    }
}

template<typename T>
void Queue<T>::append(T data) {
    tNode<T> *node = new tNode<T>;
    if(len==0){
        head = tail = node;
        iteraUpdate();
    }else {
        tail->next = node;
        tail = node;
    }
    node->data = data;
    node->next = 0;
    len++;
}

template<typename T>
bool Queue<T>::del() {
    if(isEmpty()){
        return false;
    }
    else if(len==1) {
        delete head;
        head = tail = 0;
    }
    else{
        tNode<T> *p = head->next;
        delete head;
        head = p;
    }
    iteraUpdate();
    len--;
    return true;
}

template<typename T>
T Queue<T>::get() {
    return head->data;
}

template<typename T>
bool Queue<T>::isEmpty() {
    return !(len);
}
```